{"ast":null,"code":"import axios from \"axios\";\nconst API_URL = \"http://localhost:5000/api\";\nexport const transcribeAudio = async audioFile => {\n  if (!audioFile || !(audioFile instanceof File)) {\n    throw new Error(\"A valid audio file is required\");\n  }\n  try {\n    // Create a form data object to send the audio file\n    const formData = new FormData();\n    formData.append(\"audio\", audioFile);\n\n    // Send the audio file to the server for transcription\n    const response = await axios.post(`${API_URL}/transcribe`, formData, {\n      headers: {\n        \"Content-Type\": \"multipart/form-data\"\n      }\n    });\n    if (response.data && response.data.transcript) {\n      return response.data.transcript;\n    } else {\n      throw new Error(\"No transcript returned from server\");\n    }\n  } catch (error) {\n    console.error(\"Transcription error:\", error);\n    if (error.response) {\n      throw new Error(`Server error: ${error.response.data.error || error.response.statusText}`);\n    }\n\n    // Fall back to browser-based transcription if server is not available\n    return browserTranscribeAudio(audioFile);\n  }\n};\n\n// Fallback function using browser API\nconst browserTranscribeAudio = async audioFile => {\n  return new Promise((resolve, reject) => {\n    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n    if (!SpeechRecognition) {\n      reject(new Error(\"Speech recognition not supported in this browser\"));\n      return;\n    }\n    const fileReader = new FileReader();\n    fileReader.onload = async event => {\n      try {\n        const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n        const audioData = await audioContext.decodeAudioData(event.target.result);\n        const recognition = new SpeechRecognition();\n        recognition.continuous = true;\n        recognition.interimResults = false;\n\n        // Process audio data here\n        // Note: This is a simplified implementation that may not work well\n        // Browser limitations prevent proper offline audio file transcription\n\n        resolve(\"Browser-based transcription attempted, but quality may be limited. For best results, ensure the server is running.\");\n      } catch (error) {\n        reject(new Error(`Browser audio processing error: ${error.message}`));\n      }\n    };\n    fileReader.onerror = () => reject(new Error(\"Failed to read audio file\"));\n    fileReader.readAsArrayBuffer(audioFile);\n  });\n};","map":{"version":3,"names":["axios","API_URL","transcribeAudio","audioFile","File","Error","formData","FormData","append","response","post","headers","data","transcript","error","console","statusText","browserTranscribeAudio","Promise","resolve","reject","SpeechRecognition","window","webkitSpeechRecognition","fileReader","FileReader","onload","event","audioContext","AudioContext","webkitAudioContext","audioData","decodeAudioData","target","result","recognition","continuous","interimResults","message","onerror","readAsArrayBuffer"],"sources":["E:/LETU/Transcript-Notes/Transcript-Notes/react-transcript-notes/src/services/transcriptionService.js"],"sourcesContent":["import axios from \"axios\";\r\n\r\nconst API_URL = \"http://localhost:5000/api\";\r\n\r\nexport const transcribeAudio = async (audioFile) => {\r\n  if (!audioFile || !(audioFile instanceof File)) {\r\n    throw new Error(\"A valid audio file is required\");\r\n  }\r\n\r\n  try {\r\n    // Create a form data object to send the audio file\r\n    const formData = new FormData();\r\n    formData.append(\"audio\", audioFile);\r\n\r\n    // Send the audio file to the server for transcription\r\n    const response = await axios.post(`${API_URL}/transcribe`, formData, {\r\n      headers: {\r\n        \"Content-Type\": \"multipart/form-data\",\r\n      },\r\n    });\r\n\r\n    if (response.data && response.data.transcript) {\r\n      return response.data.transcript;\r\n    } else {\r\n      throw new Error(\"No transcript returned from server\");\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Transcription error:\", error);\r\n\r\n    if (error.response) {\r\n      throw new Error(\r\n        `Server error: ${\r\n          error.response.data.error || error.response.statusText\r\n        }`\r\n      );\r\n    }\r\n\r\n    // Fall back to browser-based transcription if server is not available\r\n    return browserTranscribeAudio(audioFile);\r\n  }\r\n};\r\n\r\n// Fallback function using browser API\r\nconst browserTranscribeAudio = async (audioFile) => {\r\n  return new Promise((resolve, reject) => {\r\n    const SpeechRecognition =\r\n      window.SpeechRecognition || window.webkitSpeechRecognition;\r\n\r\n    if (!SpeechRecognition) {\r\n      reject(new Error(\"Speech recognition not supported in this browser\"));\r\n      return;\r\n    }\r\n\r\n    const fileReader = new FileReader();\r\n    fileReader.onload = async (event) => {\r\n      try {\r\n        const audioContext = new (window.AudioContext ||\r\n          window.webkitAudioContext)();\r\n        const audioData = await audioContext.decodeAudioData(\r\n          event.target.result\r\n        );\r\n\r\n        const recognition = new SpeechRecognition();\r\n        recognition.continuous = true;\r\n        recognition.interimResults = false;\r\n\r\n        // Process audio data here\r\n        // Note: This is a simplified implementation that may not work well\r\n        // Browser limitations prevent proper offline audio file transcription\r\n\r\n        resolve(\r\n          \"Browser-based transcription attempted, but quality may be limited. For best results, ensure the server is running.\"\r\n        );\r\n      } catch (error) {\r\n        reject(new Error(`Browser audio processing error: ${error.message}`));\r\n      }\r\n    };\r\n\r\n    fileReader.onerror = () => reject(new Error(\"Failed to read audio file\"));\r\n    fileReader.readAsArrayBuffer(audioFile);\r\n  });\r\n};\r\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,OAAO;AAEzB,MAAMC,OAAO,GAAG,2BAA2B;AAE3C,OAAO,MAAMC,eAAe,GAAG,MAAOC,SAAS,IAAK;EAClD,IAAI,CAACA,SAAS,IAAI,EAAEA,SAAS,YAAYC,IAAI,CAAC,EAAE;IAC9C,MAAM,IAAIC,KAAK,CAAC,gCAAgC,CAAC;EACnD;EAEA,IAAI;IACF;IACA,MAAMC,QAAQ,GAAG,IAAIC,QAAQ,CAAC,CAAC;IAC/BD,QAAQ,CAACE,MAAM,CAAC,OAAO,EAAEL,SAAS,CAAC;;IAEnC;IACA,MAAMM,QAAQ,GAAG,MAAMT,KAAK,CAACU,IAAI,CAAC,GAAGT,OAAO,aAAa,EAAEK,QAAQ,EAAE;MACnEK,OAAO,EAAE;QACP,cAAc,EAAE;MAClB;IACF,CAAC,CAAC;IAEF,IAAIF,QAAQ,CAACG,IAAI,IAAIH,QAAQ,CAACG,IAAI,CAACC,UAAU,EAAE;MAC7C,OAAOJ,QAAQ,CAACG,IAAI,CAACC,UAAU;IACjC,CAAC,MAAM;MACL,MAAM,IAAIR,KAAK,CAAC,oCAAoC,CAAC;IACvD;EACF,CAAC,CAAC,OAAOS,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,sBAAsB,EAAEA,KAAK,CAAC;IAE5C,IAAIA,KAAK,CAACL,QAAQ,EAAE;MAClB,MAAM,IAAIJ,KAAK,CACb,iBACES,KAAK,CAACL,QAAQ,CAACG,IAAI,CAACE,KAAK,IAAIA,KAAK,CAACL,QAAQ,CAACO,UAAU,EAE1D,CAAC;IACH;;IAEA;IACA,OAAOC,sBAAsB,CAACd,SAAS,CAAC;EAC1C;AACF,CAAC;;AAED;AACA,MAAMc,sBAAsB,GAAG,MAAOd,SAAS,IAAK;EAClD,OAAO,IAAIe,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACtC,MAAMC,iBAAiB,GACrBC,MAAM,CAACD,iBAAiB,IAAIC,MAAM,CAACC,uBAAuB;IAE5D,IAAI,CAACF,iBAAiB,EAAE;MACtBD,MAAM,CAAC,IAAIf,KAAK,CAAC,kDAAkD,CAAC,CAAC;MACrE;IACF;IAEA,MAAMmB,UAAU,GAAG,IAAIC,UAAU,CAAC,CAAC;IACnCD,UAAU,CAACE,MAAM,GAAG,MAAOC,KAAK,IAAK;MACnC,IAAI;QACF,MAAMC,YAAY,GAAG,KAAKN,MAAM,CAACO,YAAY,IAC3CP,MAAM,CAACQ,kBAAkB,EAAE,CAAC;QAC9B,MAAMC,SAAS,GAAG,MAAMH,YAAY,CAACI,eAAe,CAClDL,KAAK,CAACM,MAAM,CAACC,MACf,CAAC;QAED,MAAMC,WAAW,GAAG,IAAId,iBAAiB,CAAC,CAAC;QAC3Cc,WAAW,CAACC,UAAU,GAAG,IAAI;QAC7BD,WAAW,CAACE,cAAc,GAAG,KAAK;;QAElC;QACA;QACA;;QAEAlB,OAAO,CACL,oHACF,CAAC;MACH,CAAC,CAAC,OAAOL,KAAK,EAAE;QACdM,MAAM,CAAC,IAAIf,KAAK,CAAC,mCAAmCS,KAAK,CAACwB,OAAO,EAAE,CAAC,CAAC;MACvE;IACF,CAAC;IAEDd,UAAU,CAACe,OAAO,GAAG,MAAMnB,MAAM,CAAC,IAAIf,KAAK,CAAC,2BAA2B,CAAC,CAAC;IACzEmB,UAAU,CAACgB,iBAAiB,CAACrC,SAAS,CAAC;EACzC,CAAC,CAAC;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}